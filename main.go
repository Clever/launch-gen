package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"

	. "github.com/dave/jennifer/jen"
	"github.com/go-yaml/yaml"
)

// LaunchYML Schema
type LaunchYML struct {
	Env          []string `yaml:"env"`
	Dependencies []string `yaml:"dependencies"`
}

func main() {
	t := LaunchYML{}

	if len(os.Args) < 2 {
		log.Fatal("usage: launch-gen <file>")
	}

	data, err := ioutil.ReadFile(os.Args[1])
	if err != nil {
		log.Fatalf("error: %v", err)
	}

	err = yaml.Unmarshal([]byte(data), &t)
	if err != nil {
		log.Fatalf("error: %v", err)
	}

	f := NewFile("main")

	f.Comment("WARNING this file was auto-generated by launch-gen, do not modify\n")
	f.Id("")

	f.Comment("LaunchConfig is auto-generated based on the launch YML file")
	f.Type().Id("LaunchConfig").Struct(
		Id("Deps").Id("Dependencies"),
		Id("Env").Id("Environment"),
	)

	// Dependencies
	depsStruct := []Code{}
	depsInitDict := Dict{}
	for _, d := range t.Dependencies {
		depsStruct = append(depsStruct, Id(strings.Title(toPublicVar(d))).Qual(fmt.Sprintf("github.com/Clever/%s/gen-go/client", d), "Client"))
		depsInitDict[Id(strings.Title(toPublicVar(d)))] = Id(toPrivateVar(d))
	}
	f.Comment("Dependencies has clients for the service's dependencies")
	f.Type().Id("Dependencies").Struct(depsStruct...)

	// Environment
	envStruct := []Code{}
	envInitDict := Dict{}
	for _, s := range t.Env {
		envStruct = append(envStruct, List(Id(toPublicVar(s))).String())
		envInitDict[Id(toPublicVar(s))] = Id("requireEnvVar").Call(Lit(s))
	}

	f.Comment("Environment has environment variables and their values")
	f.Type().Id("Environment").Struct(envStruct...)

	////////////////////
	// InitLaunchConfig() function
	////////////////////
	lines := []Code{}
	// Setup a wag client for each dependency
	for _, d := range t.Dependencies {
		c := []Code{
			List(Id(toPrivateVar(d)), Err()).Op(":=").Qual(fmt.Sprintf("github.com/Clever/%s/gen-go/client", d), "NewFromDiscovery").Call(),
			If(Err().Op("!=").Nil()).Block(
				Qual("log", "Fatalf").Call(List(Lit("discovery error: %s"), Err())),
			),
		}
		lines = append(lines, c...)
	}

	// Return the full launch Config
	ret := Return(Id("LaunchConfig").Values(Dict{
		Id("Deps"): Id("Dependencies").Values(depsInitDict),
		Id("Env"):  Id("Environment").Values(envInitDict),
	}))

	lines = append(lines, ret)

	f.Comment("InitLaunchConfig creates a LaunchConfig")
	f.Func().Id("InitLaunchConfig").Params().Id("LaunchConfig").Block(lines...)

	// requireEnvVar function
	f.Func().Id("requireEnvVar").Params(Id("s").String()).String().Block(
		Id("val").Op(":=").Qual("os", "Getenv").Call(Id("s")),
		If(Id("val").Op("==").Lit("")).Block(
			Qual("log", "Fatalf").Call(List(Lit("env var %s is not defined"), Id("s"))),
		),
		Return(Id("val")),
	)

	err = f.Render(os.Stdout)
	if err != nil {
		panic(err)
	}
}

var (
	varOverrides []varOverride
)

type varOverride struct {
	old string
	new string
}

func init() {
	varOverrides = []varOverride{
		varOverride{
			old: "Url",
			new: "URL",
		},
	}
}

// FOO_BAR => FooBar
// foo-bar => FooBar
// foo => Foo
func toPublicVar(s string) string {
	list := []string{}
	if strings.Contains(s, "_") {
		list = strings.Split(s, "_")
	} else if strings.Contains(s, "-") {
		list = strings.Split(s, "-")
	} else {
		list = []string{s}
	}

	titledVar := ""
	for _, i := range list {
		titledVar += strings.Title(strings.ToLower(i))
	}

	out := titledVar
	for _, override := range varOverrides {
		out = strings.Replace(out, override.old, override.new, 1)
	}

	return out
}

// FOO_BAR => fooBar
// foo-bar => fooBar
// foo => foo
func toPrivateVar(s string) string {
	if s == "" {
		return s
	}
	out := toPublicVar(s)
	return strings.ToLower(string(out[0])) + out[1:]
}
