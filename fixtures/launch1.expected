package packagename

import (
	client1 "github.com/Clever/dapple/gen-go/client"
	client "github.com/Clever/workflow-manager/gen-go/client"
	"log"
	"os"
)

// Code generated by launch-gen DO NOT EDIT.

// LaunchConfig is auto-generated based on the launch YML file
type LaunchConfig struct {
	Deps Dependencies
	Env  Environment
	AwsResources
}

// Dependencies has clients for the service's dependencies
type Dependencies struct {
	WorkflowManager client.Client
	Dapple          client1.Client
}

// Environment has environment variables and their values
type Environment struct {
	EnvVarA            string
	EnvVarB            string
	TracingAccessToken string
}

// AwsResources contains string IDs that will help for accessing various AWS resources
type AwsResources struct {
	S3ReadAndWriteMe  string
	S3ReadMe          string
	S3WriteMe         string
	SQSReadAndWriteMe string
	SQSReadMe         string
	SQSWriteMe        string
}

// InitLaunchConfig creates a LaunchConfig
func InitLaunchConfig() LaunchConfig {
	workflowManager, err := client.NewFromDiscovery()
	if err != nil {
		log.Fatalf("discovery error: %s", err)
	}
	dapple, err := client1.NewFromDiscovery()
	if err != nil {
		log.Fatalf("discovery error: %s", err)
	}
	return LaunchConfig{
		AwsResources: AwsResources{
			S3ReadAndWriteMe:  getAWSNameByEnv("read-and-write-me"),
			S3ReadMe:          getAWSNameByEnv("read-me"),
			S3WriteMe:         getAWSNameByEnv("write-me"),
			SQSReadAndWriteMe: getAWSNameByEnv("read-and-write-me"),
			SQSReadMe:         getAWSNameByEnv("read-me"),
			SQSWriteMe:        getAWSNameByEnv("write-me"),
		},
		Deps: Dependencies{
			Dapple:          dapple,
			WorkflowManager: workflowManager,
		},
		Env: Environment{
			EnvVarA:            requireEnvVar("ENV_VAR_A"),
			EnvVarB:            requireEnvVar("ENV_VAR_B"),
			TracingAccessToken: os.Getenv("TRACING_ACCESS_TOKEN"),
		},
	}
}

// requireEnvVar exits the program immediately if an env var is not set
func requireEnvVar(s string) string {
	val := os.Getenv(s)
	if val == "" {
		log.Fatalf("env var %s is not defined", s)
	}
	return val
}

// getAWSNameByEnv computes the resource name and adds "-dev" unless deploy env is "production"
// We check both DEPLOY_ENV and _DEPLOY_ENV env vars, which are injected by our deployment system for Lambda and non-Lambda deployments, respectively
func getAWSNameByEnv(s string) string {
	env := os.Getenv("DEPLOY_ENV")
	if env == "" {
		env = os.Getenv("_DEPLOY_ENV")
	}
	if env == "" {
		log.Fatal("Unable to determine deployment environment (DEPLOY_ENV and _DEPLOY_ENV are undefined)")
	}
	if env == "production" {
		return s
	}
	return s + "-dev"
}
